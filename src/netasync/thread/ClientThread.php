<?php

declare(strict_types=1);

namespace netasync\thread;

use Exception;
use netasync\packet\AuthenticateClientPacket;
use netasync\NetworkBinaryStream;
use pocketmine\Thread;
use pocketmine\utils\Binary;
use ThreadedLogger;

class ClientThread extends Thread {

    /** @var int */
    public const STATUS_CONNECTING = 0;
    public const STATUS_CONNECTED = 1;
    public const STATUS_RECONNECTING = 2;
    public const STATUS_DISCONNECTED = 3;
    /** @var int */
    private int $status = self::STATUS_CONNECTING;

    /**
     * Default data
     * @var string
     */
    public const SEND_TO_LOBBY = "send:lobby";
    public const SEND_TO_FALLBACK = "send:fallback";

    /** @var ThreadedLogger */
    private ThreadedLogger $logger;
    /** @var string */
    private string $address;
    /** @var int */
    private int $port;
    /** @var array */
    private array $serverData;
    /** @var bool */
    private bool $run = true;
    /** @var resource */
    private $socket;
    /** @var PacketFactory */
    private PacketFactory $packetFactory;
    /** @var SessionThread */
    private SessionThread $sessionThread;

    /**
     * ClientThread constructor.
     * @param ThreadedLogger $logger
     * @param string $address
     * @param int $port
     * @param array $serverData
     */
    public function __construct(ThreadedLogger $logger, string $address, int $port, array $serverData) {
        $this->logger = $logger;

        $this->address = $address;

        $this->port = $port;

        $this->serverData = $serverData;

        $this->packetFactory = new PacketFactory();

        $this->sessionThread = new SessionThread();

        $this->start();
    }

    public function run() {
        $this->registerClassLoader();

        $this->connect();

        $retainedPacketBuffer = '';

        $in = new NetworkBinaryStream();

        while ($this->run) {
            if ($this->status === self::STATUS_CONNECTED) {
                try {
                    if (($data = socket_read($this->socket, 32000)) === false) {
                        $this->logger->warning('Socket returned false while socket_read');

                        $this->status = self::STATUS_RECONNECTING;
                    } else {
                        if ($retainedPacketBuffer === null) {
                            $in->setBuffer($data);
                        }else {
                            $in->setBuffer($retainedPacketBuffer . $data);

                            $retainedPacketBuffer = null;
                        }

                        while (!$in->feof()) {
                            $currentIndex = $in->getOffset();

                            try {
                                $buffer = new NetworkBinaryStream($in->get($in->getShort()));

                                $pid = $buffer->readInt();

                                $pk = $this->packetFactory->getPacket($pid);

                                if ($pk === null) {
                                    $this->logger->error('Unknown packet with PID ' . $pid);
                                } else {
                                    $pk->decode($buffer);

                                    $this->sessionThread->add($pk);
                                }
                            } catch (Exception $e) {
                                if (strpos($e->getMessage(), 'Not enough bytes.') !== false) {
                                    $in->setOffset($currentIndex);

                                    $retainedPacketBuffer = $in->get(strlen($in->getBuffer()) - $currentIndex);

                                    continue;
                                }

                                $this->logger->warning('Exception in NetAsync ClientThread');

                                $this->logger->logException($e);
                            }
                        }
                    }
                } catch (Exception $e) {
                    $this->logger->error('Error while parsing packet frame: ');
                    $this->logger->error($e->getMessage());
                    $this->logger->error($e->getTraceAsString());
                }
            }
        }
    }

    public function quit() {
        $this->run = false;

        $this->status = self::STATUS_DISCONNECTED;

        parent::quit(); // TODO: Change the autogenerated stub
    }

    private function connect(): void {
        try {
            $newSocket = $this->createSocket();
        } catch (Exception $exception) {
            $this->logger->error('Error while creating socket resource for reconnect: ' . $exception->getMessage());

            return;
        }

        if ($newSocket !== null) {
            $this->status = self::STATUS_CONNECTED;

            $this->socket = $newSocket;

            $pk = new AuthenticateClientPacket();

            $pk->description = $this->serverData['description'];

            $pk->group = $this->serverData['group'];

            $pk->password = $this->serverData['password'];

            $pk->isLobbyServer = $this->serverData['isLobbyServer'];

            $this->writePacket($pk->encode());

        } else {
            $this->status = self::STATUS_RECONNECTING;
        }
    }

    /**
     * @return resource
     */
    private function createSocket() {
        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);

        if ($socket !== false) {
            $connect = socket_connect($socket, $this->address, $this->port);

            if ($connect) return $socket;
        }

        return null;
    }

    /**
     * @param NetworkBinaryStream $stream
     */
    public function writePacket(NetworkBinaryStream $stream): void {
        $stream->setBuffer(Binary::writeShort(strlen($stream->getBuffer())) . $stream->getBuffer());

        try {
            if (!socket_write($this->socket, $stream->getBuffer())) {
                $this->status = self::STATUS_RECONNECTING;

                $this->logger->warning('Socket write failed, initiating reconnect (' . socket_last_error($this->socket) . '): ' . socket_strerror(socket_last_error($this->socket)));
            }
        } catch (Exception $e) {
            $this->status = self::STATUS_RECONNECTING;

            $this->logger->warning('Error while writing to socket: ' . $e->getMessage());

            $this->logger->warning('Triggering reconnect');
        }
    }

    public function disconnect(): void {
        $this->run = false;

        $this->status = self::STATUS_DISCONNECTED;
    }

    private function close(): void {
        if ($this->socket !== null) {
            try {
                socket_shutdown($this->socket);
            } catch (Exception $e) {
                $this->logger->error('Error while shutting down socket');

                $this->logger->logException($e);
            }
        }
    }

    /**
     * @return int
     */
    public function getStatus(): int {
        return $this->status;
    }

    /**
     * @return SessionThread
     */
    public function getSessionThread(): SessionThread {
        return $this->sessionThread;
    }
}